# Пакетные менеджеры

[Статьи](../../stats.md) > [Строение GNU/Linux](../LinuxStr.preview.md)

<pre>
<strong>Автор:</strong> <a href="/LinuxSovet/Group/authors.d/Linuxoid85.html">Михаил Краснов</a>
<strong>Дата написания:</strong> 05.07.2021 00:00
</pre>

## Прелюдия

Доброго времени суток! Цикл "Строение GNU/Linux" оказался довольно популярным - видимо, народу было интересно. Этот цикл я представлял себе намного объёмнее, чем сейчас, но что есть, то есть. Но, несмотря на это, статьи отсюда, пусть и в довольно модифицированном виде, вошли в руководство "[Linux для себя](https://lx4u.ru)".

Да, этот цикл давно не обновлялся, но это не значит, что он устарел.

## Введение

Первая версия этой статьи была простым обзором известных пакетных менеджеров, да и к тому же, она содержала очень большое число фактических ошибок и неточностей. Эту было бы банальным, ведь таких же статей - куча, да и использование пакетного менеджера - не единственный метод управления программным обеспечением, поэтому текущую версию статьи разнообразил сведениями о сборке программного обеспечения из исходного кода.

## Методы управления ПО в GNU/Linux

Грубо говоря, есть два метода управления ПО в GNU/Linux:

1. Установка уже собранных бинарных пакетов;
2. Сборка программного обеспечения из исходного кода.

У каждой программы для GNU/Linux есть *зависимости* - другие пакеты, без которых искомый не сможет работать, либо будет лишён каких-либо функций. Зависимости можно разделить на следующие категории:

- **Обязательные**. Без них пакет не может функционировать вообще. Если какая-то из обязательных зависимостей не будет присутствовать в конкретном дистрибутиве GNU/Linux, то искомый пакет либо не сможет быть собран из исходного кода, а все пакетные менеджеры, в которых присутствует обработка зависимостей (`dpkg`, `apt`, `apt-get`, `rpm`, `dnf`, etc.), либо установят эту обязательную зависимость (высокоуровневые пакетные менеджеры, такие как dnf, apt-get, apt, etc.), либо завершат установку с ошибкой (низкоуровневые ПМ, такие как dpkg или rpm).
- **Рекомендуемые**. Эти зависимости рекомендуются сборщиками для установки вместе с искомым пакетом. Возможно, без них он не будет работать корректно при выполнении каких-то определённых задач, либо будет лишён какого-то доп. функционала. Это *необязательные зависимости*.
- **Опциональные**. Ещё один тип необязательных зависимостей. Добавляют какой-то доп. функционал искомому пакету, особо больше нечего сказать.
- **Конфликтующие**. Если в этой секции указан пакет, который установлен в системе, то перед установкой искомого пакета, требуется удалить из системы конфликтующий. Возможно, в этих пакетах предоставляются разные версии какой-либо одной библиотеки, либо конфликтуют какие-либо другие файлы. Во избежание ошибок в работе отдельного ПО или всей системы в целом пакетные менеджеры с обработкой зависимостей удаляют перечисленные в этой секции пакеты перед установкой искомого пакета.

## Что такое пакет?

Пакет - это архив с файлами программы и информацией о ней. Информация о пакете включает в себя:

- Имя программы/библиотеки/etc.
- Версия программы
- Описание программы
- Информация о сопровождающем (сборщике) пакета
- Зависимости пакета
- Все файлы, включенные в пакет (используется не во всех ПМ, так как некоторые умеют сами перечислять файлы пакета, а некоторым требуется указать список файлов самостоятельно).

Информация, представленная выше, используется как человеком, так и пакетными менеджерами, созданные для упрощения управления пакетами.

По содержимому, в свою очередь, пакеты можно разделить на две группы:

1. **Бинарные пакеты**. Содержат уже собранные двоичные файлы пакета.
2. **src-пакеты**. Содержат инструкции по сборке. Редки, но иногда можно встретить и их. Сборочные инструкции, как правило, представляют Shell-скрипт, который запускается пакетным менеджером. Просьба ***не путать*** такие src-пакеты, по-сути, "собираемые" пакетным менеджером, с обычными архивами исходного кода требуемого пакета.

***

## Сборка программного обеспечения из исходного кода

Часть дистрибутивов GNU/Linux предлагают не установку бинарных пакетов, а сборку ПО из исходного кода. Самым известным таким дистрибутивом является, конечно же, Gentoo. В книгах/руководствах LFS и LX4U для создания своего дистрибутива GNU/Linux требуется собрать необходимое ПО исключительно из исходного кода. Кроме того, сборка ПО из сорцов может пригодиться тогда, когда для дистрибутива, которым пользуется человек, нет нужного пакета, так как его разработчик не удосужился собрать бинарные пакеты для конкретного дистрибутива.

> Далее, с вашего позволения, я буду описывать управление пакетами в типичной системе, собранной по LFS или LX4U, так как там как раз-таки и практикуется метод сборки ПО из исходного кода. Кроме того, там нет никаких усложнений, присущих более "продвинутым" системам.

С одной стороны, при использовании пакетного менеджера (ПМ) значительно упрощается управление ПО, так как ПМ позволяет отслеживать установку файлов, делая процесс удаления и/или обновления пакетов значительно проще. Кроме того, ПМ способен следить за конфликтами файлов при установке пакета (например, в пакете `пакет1` и `пакет2` содержатся разные версии одной и той же библиотеки. ПМ должен обнаружить это и, например, прервать установку какого-то из пакетов, дабы избежать всевозможных конфликтов).

### Методы управления пакетами, собранными из исходного кода

Конечно, здесь рассматривается тот случай, когда вся система собрана из исходного кода. Так как в самой обычной системе несколько сотен пакетов, то и управление ими (а, в особенности, их удаление или обновление до новой версии) может быть проблематичным. Ниже рассмотрены основные практики управления таким ПО.

**1. Держать всё в голове.**

Некоторые читатели зададутся вопросом: "А что это за метод такой?". Да, это метод управления ПО. Есть такие пользователи, которым не нужны утилиты для управления пакетами в системе, так как они и сами знают каждый пакет и какой файл к какому пакету принадлежит. Это довольно сложный метод, да и память у человека не резиновая.

Достоинства:
1. Не используется пакетные менеджеры и прочие утилиты для управления ПО. Достаточно сомнительное достоинство. Хотя в минималистичных системах может быть решающим.

Недостатки:
1. Довольно сложный метод, требующий от человека хорошей памяти для того, чтобы помнить версию пакета, его предназначение, зависимости и прочее. И, что самое главное, список файлов, принадлежащих пакету. При использовании большого числа пакетов эта техника становится неуправляемой.

**2. Установка каждого пакета в отдельные директории.**

Что-то подобное реализовано в NixOS (за исключением того, что это не совсем source-based дистрибутив). Метод довольно простой и понятный, использовать его может каждый. К примеру, есть пакет с именем `pkg1`. Он собирается самым обычным методом (`configure`, `make`), а вот устанавливается в отдельную директорию, к примеру, `/usr/pkgs/pkg1`. В этой директории впоследствии будет создана файловая иерархия как в корне (`/bin`, `/sbin`, `/etc` и пр.) и установлен пакет. После чего из `/usr/pkgs/pkg1/` создаются необходимые ссылки в `/` (например, ссылки на бинарные файлы из `/usr/pkgs/pkg1/bin*` в `/bin/`).

Достоинства:
1. Не требуется программа для управления ПО - каждая программа содержится в отдельной директории. Удобно и просто!
2. Очень лёгкое обновление пакета, либо же его удаление. Достаточно удалить директорию с ним!

Недостатки:
1. Переменные окружения `PATH`, `LD_LIBRARY_PATH`, `MATPATH` и прочие приходится расширить, включив в них директорию с пакетом. Как и в предыдущем случае, этот метод может быть неуправляемым в случае, если используется большое число пакетов.

**3. Использование системы портов.**

Система портов - это набор файлов, в котором содержатся инструкции для сборки и установки пакета, информация о пакете, список устанавливаемых файлов и прочее. Это используется, например, в Gentoo Linux (portage). Про *BSD системы писать здесь не буду, так как это не тема статьи, но там тоже это встречается, например, коллекция портов FreeBSD.

Для системы портов легко можно написать утилиту для её управления, в задачи которой входит:

1. Сборка пакета, используя инструкции из системы портов;
2. Ведение базы данных установленных пакетов;
3. Удаление пакетов;
4. Просмотр информации о пакетах;

И другое.

## Процесс сборки пакета из исходного кода

Этот процесс можно разделить на следующие этапы:

1. Загрузка архива(ов) с исходным кодом пакета.
2. Распаковка архива(ов). В результате этого будет распакована директория, в которой содержится сам исходный код.
3. Переход в эту директорию.
4. Конфигурирование пакета. Как правило, это выполняется с помощью запуска скрипта `configure` с переданными ему необходимыми параметрами. В результате чего будет создан `Makefile`. В том случае, если скрипта `configure` не существует, то его нужно создать. Как правило, то выполняется программами из пакета `autoconf`.
5. Компиляция пакета. Как правило это выполняется с помощью `make`.
6. Установка пакета. `make install`.
7. Выход из директории с исходным кодом и её удаление.

К примеру, у нас есть пакет `pkg1`. Архив с исходным кодом находится по адресу `https://www.pkg1.org/pub/pkg1-1.0.tar.xz`. Сборка выполняется посредством `make`.

```bash
# Загрузка:
wget https://www.pkg1.org/pub/pkg1-1.0.tar.xz

# Распаковка:
tar -xf pkg1-1.0.tar.xz

# Переход в директорию с исходным кодом:
cd pkg1-1.0

# Конфигурирование:
./configure --prefix=/usr --localstatedir=/var --disable-static

# Компиляция:
make -j4
# -j4 - указание потоков сборки, например. Использование необязательно.

# Установка:
make install

# Выход из директории с исходным кодом и её удаление:
cd ..
rm -rf pkg1-1.0
```

Кроме того, перед выполнением сборки было бы неплохим почитать содержимое файлов `README` и `INSTALL` - там содержится достаточно информации для того, чтобы понять предназначение пакета и процесс его сборки.

***

## Использование пакетного менеджера как средство управления программным обеспечением

Использование пакетного менеджера (и, соотв., бинарных пакетов) - это самый распространённый метод. Как уже было написано ранее, пакетный менеджер - это утилита для установки, удаления, обновления пакетов, а также просмотра о них информации.

### Типы пакетных менеджеров

Пакетные менеджеры можно разделить на две подгруппы:

- **Низкоуровневые**. `dpkg` из Debian, `rpm` из RHEL.
- **Высокоуровневые**. `apt-get`, `apt`, `aptitude`, `apt-rpm`, `dnf`, `zypper`, `pacman` и пр. Как правило, являются надстройками над низкоуровневыми (кроме `pacman` в этом списке). Но это не обязательно.

Самым главным различием между типами является то, что низкоуровневые ПМ способны устанавливать только локальные пакеты, т.е. те, которые в данный момент находятся на жёстком диске ПК. Высокоуровневые же, наоборот, скачивают пакет с какого-либо репозитория, после чего выполняют его установку.

Кроме того, большинство высокоуровневых ПМ способны выполнять очистку системы от неиспользуемых зависимостей (помнится, `urpmi` из Mandriva Linux, а также графический интерфейс для него (честно говоря, уже забыл название, но что-то вроде `rpmdrake`) называл такие пакеты "сиротскими").

В обоих типах присутствует обработка зависимостей. Но опять же - низкоуровневые ПМ не способны скачивать ПО из репозиториев конкретного дистрибутива, поэтому в случае отсутствия нужной зависимости в системе (т.е. когда эта зависимость или не установлена, или отсутствует в виде пакета в той же директории, в которой содержится искомый пакет) будет выведена ошибка и установка искомого пакета завершится. В случае высокоуровневого ПМ перед установкой искомого пакета будет построено дерево зависимостей, содержащее список необходимых к установке пакетов, а также порядок их установки. По этому дереву впоследствии будут скачаны нужные пакеты, а потом в построенном порядке они будут установлены.
