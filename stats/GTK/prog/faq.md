# Основные вопросы

Это указатель справочного руководства, организованный по общим вопросам типа *"Как мне..."*. Если вы не знаете, какую документацию прочитать по заданному вами вопросу, этот список - хорошее место для начала.

## Базовые вопросы

* Как мне начать работу с GTK?

[Вебсайт GTK](https://www.gtk.org/) предлагает несколько [учебных пособий](https://www.gtk.org/documentation.php) и другую документацию (большая часть из них касается GTK 2.x и 3.х, но всё же в некоторой степени применима и к GTK4). Это справочное руководство так же содержит вводную часть "Начала работы".

* Где я могу получить помощь по GTK, отправить [отчёт об ошибке](https://gitlab.gnome.org/GNOME/gtk/issues/new) или запросить функцию?

Смотрите эту документацию.

* Как перенести программу с одной версии GTK на другую.

Смотрите руководство по миграции (*прим. переводчика: в данной статье я не нашёл ссылок на это рук-во*). Вы также можете найти полезную информацию в документации по конкретным виджетам и функциям. Если у вас есть вопрос, не описанный в руководстве, не стесняйтесь спрашивать и отправлять [отчёты об ошибках](https://gitlab.gnome.org/GNOME/gtk/issues/new) в документации.

* Как работает управление памятью в GTK? Должен ли я освобождать данные, возвращаемые функциями?

Смотрите документацию для `GObject` и `GInitiallyUnowned`. Для `GObject` обратите внимание, в частности, на `g_object_ref()` и `g_object_unref()`. GInitiallyUnowned является подклассом GObject, поэтому применяются те же пункты, за исключением того, что он имеет "плавающее" состояние (объяснено в документации).

Для строк, выводимых из функций, они будут объявлены "константными", если их не нужно освобождать. Неконстантные строки следует освобождать с помощью `g_free()`. Массивы подчиняются тому же правилу. Если вы обнаружите недокументированное исключение из правил, отправьте [отчёт об ошибке](https://gitlab.gnome.org/GNOME/gtk/issues/new).

Аннотации передачи для `gobject-introspection`, которые являются частью документации, так же могут представить полезные подсказки для семантики обработки памяти.

* Почему у моей программы происходит утечка памяти, если я уничтожаю виджет сразу после его создания?

Если `GtkFoo` не является окном верхнего уровня, тогда:

```c
foo = gtk_foo_new();
g_object_unref (foo);
```

-- это утечка памяти, потому что никто не предполагал исходную плавающую ссылку (вы тоже получите предупреждение об этом). Если вы используете виджет и не сразу упаковываете его в контейнер, то вам, вероятно, нужен стандартный подсчёт ссылок, а не плавающий.

Чтобы получить это, вы должны получить ссылку на виджет и отбросить плавающую ссылку (`ref` и `sink` на языке GObject) после её создания:

```c
foo = gtk_foo_new();
g_object_ref_sink (foo);
```

* Как использовать GTK с потоками?

GTK требует, чтобы все вызовы API GTK выполнялись из того же потока, в котором было создано приложение [`GtkApplication`](https://developer.gnome.org/gtk4/stable/GtkApplication.html#GtkApplication-struct) или был вызван [`gtk_init()`](https://developer.gnome.org/gtk4/stable/gtk4-General.html#gtk-init) (основной поток).

Если вы хотите воспользоваться преимуществами многопоточности в приложениях GTK, обычно лучше всего отправлять длительные задачи рабочим потокам и передавать результаты обратно в основной поток с помощью `g_idle_add()` или `GAsyncQueue`. GIO предлагает полезные инструменты для такого подхода, например `GTask`.

* Как я могу интернационализировать программу на GTK? (*прим. передодчика: интернационализировать = перевести на другой язык*).

Большинство людей использует [GNU Gettext](https://www.gnu.org/software/gettext/), который является необходимой зависимостью для установки GLib. В системе UNIX или Linux с установленным `gettext` выполните:

```bash
man gettext
```

или:

```bash
info gettext
```

для получения дополнительных сведений.

Краткое рук-во по использованию gettext. Вызовите `bindtextdomain()`, чтобы gettext мог найти файлы, содержащие ваши переводы, вызовите `textdomain()`, чтобы установить домен перевода по умолчанию, вызовите `bind_textdomain_codeset()`, чтобы запросить возвращение всех переведённых строк в UTF-8, затем вызовите `gettext()`, чтобы найти каждую строку для перевода в домене по умолчанию.

Для удобства, `gi18n.h` предоставляет следующие сокращённые макросы. Обычно для удобства люди определяют их следующим образом:

```c
#define  _(x)     gettext (x)
#define N_(x)     x
#define C_(ctx,x) pgettext (ctx, x)
```

Вы используете `N_()` (`N` обозначает `no-op`), чтобы пометить строку для перевода в месте, где вызов функции `gettext()` не разрешён, например, в инициализаторе массива. В конце концов вам придётся вызывть `gettext()` в строке, чтобы получить перевод. `_()` отмечает строку для перевода и фактически переводит её. Макрос `C_()` (`C` означает *контекст*) добавляет дополнительный контекст к строке, помеченной для перевода, что может помочь устранить неоднозначность коротких строк, которые могут нуждаться в разных переводах в разных местах вашей программы.

Код, использующий эти макросы, в итоге выглядит так:

```c
#include <gi18n.h>

static const char *global_variable = N_("Translate this string");

static void
make_widgets (void)
{
  GtkWidget *label1;
  GtkWidget *label2;

  label1 = gtk_label_new (_("Another string to translate"));
  label2 = gtk_label_new (_(global_variable));
...
```

Библиотеки, использующие gettext, должны использовать `dgettext()` вместо `gettext()`, что позволяет им указывать домен перевода каждый раз, когда они запрашивают перевод. Библиотеки такде должны избегать вызова `textdomain()`, поскольку они будут указывать домен вместо использования по умолчанию.

Согласно соглашению о том, что макрос `GETTEXT_PACKAGE` определён для хранения вашего домена перевода библиотек, можно включить `gi18n-lib.h` для обеспечения следующего удобства:

```c
#define _(x) dgettext (GETTEXT_PACKAGE, x)
```

* Как использовать символы, отличные от ASCII, в программах GTK?


