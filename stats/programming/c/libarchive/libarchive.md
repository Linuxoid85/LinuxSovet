# Примеры работы с libarchive

Здесь приведены примеры короткого кода, иллюстрирующие использование библиотеки.

На этой странице собрано несколько коротких примеров, иллюстрирующих работу libarchive. Цель - предоставить базовые шаблоны, которые можно скопировать и использовать для начала вашей собственной разработки.

Весь код на этой странице находится в открытом доступе. Вы можете использовать его для любых целей. Обратите внимание на то, что сам libarchive не является общественным достоянием; для получения дополнительной информации прочитайте текст лицензии в дистрибутиве. Если есть пример, который вы бы хотели поместить сюда, то спросите у нас, как это сделать.

## Список содержимого архива, хранящегося в файле

libarchive основан на двух типах "объектов": объекты архива (указатели на `struct archive`) и входные объекты (указатели на `struct archive_entry`). Это непрозрачные ссылки: вы не можете напрямую обращаться к полям структуры, вы можете только вызывать функции libarchive, которые создают, манипулируют и уничтожают эти объекты за вас.

Базовый жизненный цикл архива очень прост:

* Создайте его с помощью `archive_XXX_new()`;
* Настройте его с помощью вызовов `support` или `set` (вызовы "support" позволяют libarchive решать, когда использовать функцию, вызовы "set" включают эту функцию безоговорочно);
* "Откройте" (`open`) конкретный источник данных;
* Переберите содержимое: поочерёдно запрашивайте "заголовок" (`header`) (который возвращает объект записи, описывающий следующую запись в архиве) и "данные" (`data`);
* Когда вы закончите, вы можете "закрыть" (`close`), запросить любую окончательную информацию или статистику, а затем вызвать `free`, чтобы освободить объект архива (вызовы `free` раньше назывались `finish` в ранних версиях libarchive).

Запись архива очень похожа, за исключением того, что вы предоставляете заголовок (header) и данные (data) в libarchive, вместо того, чтобы запрашивать их.

Вот очень простой пример, который просто открывает файл и перечисляет содержимое архива:

```c
struct archive *a;
struct archive_entry *entry;
int r;

a = archive_read_new();
archive_read_support_filter_all(a);
archive_read_support_format_all(a);
r = archive_read_open_filename(a, "archive.tar", 10240); // Примечание 1
if (r != ARCHIVE_OK)
  exit(1);
while (archive_read_next_header(a, &entry) == ARCHIVE_OK) {
  printf("%s\n",archive_entry_pathname(entry));
  archive_read_data_skip(a);  // Примечание 2
}
r = archive_read_free(a);  // Примечание 3
if (r != ARCHIVE_OK)
  exit(1);
```

### Примечания

**Примечание 1**. Начиная с libarchive 3.0, функция `archive_read_open_filename()` проверяет файл перед тем, как решить, как обрабатывать размер блока. Если указанное имя файла относится, например, к ленточному устройству, оно будет использовать именно тот размер блока, который вы указали. Для других устройств он может отрегулировать запрошенный размер блока, чтобы полусить наилучшую производительность.

**Примечание 2**. Вызов `archive_read_data_skip()` здесь на самом деле не нужен, поскольку libarchive вызовет его автоматически, если вы запросите следующий заголовок, не читая данные для последней записи.

**Примечание 3**. Эта функция раньше называлась `archive_read_finish()` в более ранних версиях libarchive. Это имя останется доступным как минимум несколько лет.

## Список содержимого архива, хранящегося в памяти

Есть несколько вариантов функций открытия (`open`). Вариант `filename`, использованный выше, предназначен для простоты использования в общем случае, но иногда вы можете найти вариант `memory` более полезным:

```c
struct archive *a = archive_read_new();
archive_read_support_compression_gzip(a);
archive_read_support_format_tar(a);
r = archive_read_open_memory(a, buff, sizeof(buff));
```

Обратите внимание, что вариант `filename` принимает размер блока, указывающий, насколько большим будет каждое чтение с диска. В случае с памятью всё, что нужно - это общий размер архива, хранящегося в памяти.

Существуют так же варианты чтения из уже открытого файлового дескриптора (что полезно в том случае, когда вам нужно пропустить первую часть архива перед использованием libarchive для извлечения остальных) или указателя `FILE*`.

## Список содержимого архива с настраиваемыми функциями чтения

Иногда ни одна из упакованных функций `open` не работает для вас. В этом случае вы можете использовать функцию нижнего уровня (low-level) `archive_read_open`. Она принимает три обратных вызова и указател на ваши данные:

* Открытый обратный вызов. Это унаследовано, в нём нет необходимости и его не следует использовать.
* Обратный вызов чтения.
* Обратный вызов закрытия (a close callback).

Например, вы можете реализовать настраиваемую функцию обратного вызова чтения, которая вызывается в библиотеку HTTP для извлечения данных по мере их загрузки с веб-сайта.

Все обратные вызовы используют определённые соглашения о libarchive:

* Функции открытия и закрытия возвращают `ARCHIVE_OK` (ноль) в случае успеха или отрицательное значение в случае ошибки. Наиболее распространённые значения здесь: `ARCHIVE_WARN` для чего-то, что было не идеально (предупреждение - прим. переводчика), или `ARCHIVE_FATAL` для сбоя, который невозможно повторить или восстановить.
* Обратный вызов чтения возвращает кол-во прочитанных байтов, ноль для конца файла или отрицательный код ошибки, как указано выше. Он так же возвращает указатель на блок прочитанных данных.
* libarchive не волнует, насколько большие блоки. Он будет полностью использовать любой блок, прежде чем запрашивать следующий, поэтому вашим обратным вызовам не нужно обрабатывать частично прочитанные блоки. Единственное требование - каждый блок должен состоять как минимум из одного байта, поскольку нулевой байт указывает на конец файла.

Вот простой пример использования ваших обратных вызовов. Для краткости здесь опущено множество операций по обработке ошибок. В частности, обратите внимание, как пользователь `mydata` передаётся обратно в ваши обратные вызовы, чтобы вы могли управлять своими личными данными по своему усмотрению.

```c
void
list_archive(const char *name)
{
  struct mydata *mydata;
  struct archive *a;
  struct archive_entry *entry;
  mydata = malloc(sizeof(struct mydata));
  a = archive_read_new();
  mydata->name = name;
  mydata->fd = open(mydata->name, O_RDONLY); // Include O_BINARY on Windows
  archive_read_support_compression_all(a);
  archive_read_support_format_all(a);
  archive_read_open(a, mydata, NULL, myread, myclose);
  while (archive_read_next_header(a, &entry) == ARCHIVE_OK) {
    printf("%s\n",archive_entry_pathname(entry));
  }
  archive_read_finish(a);
  free(mydata);
}
ssize_t
myread(struct archive *a, void *client_data, const void **buff)
{
  struct mydata *mydata = client_data;
  *buff = mydata->buff;
  return (read(mydata->fd, mydata->buff, 10240));
}
int
myclose(struct archive *a, void *client_data)
{
  struct mydata *mydata = client_data;
  if (mydata->fd > 0)
    close(mydata->fd);
  free(mydata);
  return (ARCHIVE_OK);
}
```

[LibarchiveIO](https://github.com/libarchive/libarchive/wiki/LibarchiveIO) содержит более подробную информацию о разработке и реализации эффективных функций обратного вызова ввода-вывода.

### Примечание об обратном вызове пропуска

Функция `archive_read_open2()` похожа на функцию `archive_read_open()`, но она принимает дополнительную функцию обратного вывода `skip`. Обратный вызов пропуска не требуется. Однако, если он доступен, libarchive может оптимизировать определённые операции чтения. В частности, ни один из приведённых выше примеров не читает тело записи архива. Для некоторых форматов архивов libarchive может вызывать обратный вызов `skip` для быстрого поиска по всей записи тела.

Обратный вызов `skip` должен удовлетворять следующим условиям:

* Он должен возвращать кол-во фактически пропущенных байтов или открицательный код ошибки, если пропустить невозможно.
* Он может пропустит меньше байтов, чем запрошено, но никогда не должен пропускать больше.
* Когда-либо будут запрашиваться только positive/forward пропуски вперёд.
* Если пропуск не предусмотрен или не работает, libarchive вызовет функцию `read()` и просто проигнорирует любые данные, которые ему не нужны.

**Примечание**. Сигнатура вызова `skip` немного изменилась с выходом libarchive 3.0. Предыдущие версии использовали тип данных платформы `off_t` для обозначения смещений для пропуска. Это не совсем переносимо, поэтому libarchive 3.0 вместо этого использует типы данных `int64_t`. Если вам нужно написать код, который будет компилироваться как с libarchive 3.0, так и с более ранними версиями, вам может потребоваться определить различные типы ваших обратных вызовов в зависимости от макроса `ARCHIVE_VERSION_NUMBER`. Спросите на [libarchive-discuss@groups.google.com](mailto:libarchive-discuss@groups.google.com), если у вас есть вопросы по этому поводу.

## Примечание об обратном вызове поиска

libarchive 3.0 теперь может поддерживать обратный вызов `_seek_`. Обратный вызов `_seek_` используется для чтения форматов архивов, которые не поддаются потоковой передаче, таких как 7-Zip и некоторые варианты Zip.

**Будьте осторожны:** если вы предоставляете функцию обратного вызова поиска, вы гарантируете, что она будет работать. В частности, система `lseek()` или `fseek()` обычно не работает с ленточными файлами, некоторыми необработанными дисковыми устройствами, каналами или сетевыми сокетами. Если вы предоставляете обратный вызов `seek`, который просто вызывает системную функцию для такого файла, libarchive, скорее всего, сильно запутается.

## Универсальный распаковщик (декомпрессор)

Начиная с libarchive 2.8, существует обработчик "raw" ("сырого") формата, который обрабатывает произвольный двоичный ввод как одноэлементный архив. По сути, это фича (чит), позволяющая вам получить вывод цепочки фильтров libarchive, включая файлы с несколькими кодировками, такие как `gz.uu`:

```c
int r;
ssize_t size;

struct archive *a = archive_read_new();
archive_read_support_compression_all(a);
archive_read_support_format_raw(a);
r = archive_read_open_filename(a, filename, 16384);
if (r != ARCHIVE_OK) {
  /* ERROR */
}
r = archive_read_next_header(a, &ae);
if (r != ARCHIVE_OK) {
  /* ERROR */
}

for (;;) {
  size = archive_read_data(a, buff, buffsize);
  if (size < 0) {
    /* ERROR */
  }
  if (size == 0)
    break;
  write(1, buff, size);
}

archive_read_free(a));
```

Обратите внимание, что raw формат не разрешён функцией `archive_read_support_format_all()`. Так же обратите внимание, что обработчик необработанного формата не распознаёт и не принимает пустые файлы. Если вы специально хотите иметь возможность читать пустые файлы, вам так же необходимо вызвать `archive_read_support_format_empty()`.

## Простой пример записи

Ниже приводится довольно простой пример использования libarchive для записи группы файлов в сжатый tar-архив (с помощью gzip). Это немного сложнее, чем предыдущие примеры чтения, потому что пример записи действительно что-то делает с телами файлов.

```c
void
write_archive(const char *outname, const char **filename)
{
  struct archive *a;
  struct archive_entry *entry;
  struct stat st;
  char buff[8192];
  int len;
  int fd;

  a = archive_write_new();
  archive_write_add_filter_gzip(a);
  archive_write_set_format_pax_restricted(a); // Примечание 1
  archive_write_open_filename(a, outname);
  while (*filename) {
    stat(*filename, &st);
    entry = archive_entry_new(); // Примечание 2
    archive_entry_set_pathname(entry, *filename);
    archive_entry_set_size(entry, st.st_size); // Примечание 3
    archive_entry_set_filetype(entry, AE_IFREG);
    archive_entry_set_perm(entry, 0644);
    archive_write_header(a, entry);
    fd = open(*filename, O_RDONLY);
    len = read(fd, buff, sizeof(buff));
    while ( len > 0 ) {
        archive_write_data(a, buff, len);
        len = read(fd, buff, sizeof(buff));
    }
    close(fd);
    archive_entry_free(entry);
    filename++;
  }
  archive_write_close(a); // Примечание 4
  archive_write_free(a); // Примечание 5
}

int main(int argc, const char **argv)
{
  const char *outname;
  argv++;
  outname = *argv++;
  write_archive(outname, argv);
  return 0;
}
```

### Примечания

**Примечание 1**. Формат "pax restricted" в libarchive - это формат tar, в котором расширения `pax` используются только в случае крайной необходимости. В большинстве случаев он будет писать постые записи `ustar`. Это рекомендуемый формат tar для большинства случаев использования. Вы должны явно использовать формат `ustar` только тогда, когда вам нужно создать архивы, которые будут доступны для чтения в старых системах; вам следует явно запрашивать формат `pax` только тогда, когда вам нужно сохранить как можно больше атрибутов.

**Примечание 2**. В этом примере создаётся новый объект `archive_entry` для каждого файла. Для лучшей производительности вы можете повторно использовать один и тот же объект `archive_entry`, используя `archive_entry_clear()`, чтобы стирать его после каждого использования.

**Примечание 3**. Здесь обязательными атрибутами являются размер, тип файла и путь. Вы так же можете использовать `archive_entry_copy_stat()` для копирования всей информации из `struct stat` в запись архива, включая тип файла. Чтобы получит ещё более подробную информацию, взгляните на API `archive_read_disk`, предоставляющий простой способ получить более обширные метаданные файла - включая списки контроля доступа и расширенные атрибуты в некоторых системах - чем при использовании вызова `stat()` (прим. переводчика - перевод этого предложения может быть не точным). Он так же работает на Windows, где `stat()` либо отсутствует, либо не работает.

**Примечание 4**. При необходимости вызов `free`/`finish` неявно вызовет `archive_write_close()`. Однако вызов закрытия возвращает код ошибки, а вызов `free`/`finish` - нет, поэтому, если вы полагаетесь на неявное закрытие, вы не сможете обнаружить какие-либо ошибки, возникающие при окончательной записи.

**Примечание 5**. Начиная с libarchive 3.0, эта функция называется `archive_write_free()`. Предыдущее название было `archive_write_finish()`. Если вы хотите написать ПО, совместимое с libarchive 2.x и 3.х, то используйте старое имя, но имейте в виду, что такое поведение будет удалено после выхода версии 4.х.

## Создание объектов на диске

libarchive включает в себя средство `archive_write_disk`, работающее очень похоже на `archive_write`, за исключением того, что оно создаёт объекты на диске вместо добавления записей в архив. Ср-во `archive_write_disk` умеет создавать каталоги, файлы, символические и жёсткие ссылки, а так же другие типы дисковых объектов. Вот простой пример, демонстрирующий использование libarchive для создания обычного файла на диске:

```c
struct archive *a;
struct archive_entry *entry;

a = archive_write_disk_new();
archive_write_disk_set_options(a, ARCHIVE_EXTRACT_TIME);

entry = archive_entry_new();
archive_entry_set_pathname(entry, "my_file.txt");
archive_entry_set_filetype(entry, AE_IFREG); // Примечание 1
archive_entry_set_size(ae, 5);  // Примечание 2
archive_entry_set_mtime(ae, 123456789, 0);
archive_write_header(a, entry);
archive_write_data(a, "abcde", 5); // Примечание 3
archive_write_finish_entry(a);
archive_write_free(a);
archive_entry_free(entry);
```

### Примечания

**Примечание 1**. Заголовок `archive_entry.h` определяет набор констант `AE_XXXXX` для различных типов файлов. Они такие же, как и константы `IF_XXXXX`, которые определены во многих системах, за исключением того, что не все системы имеют полный набор определений `IF_XXXXX` в стандартных заголовках.

**Примечание 2**. Если вы установите размер в записи, объект `archive_write_disk` будет применять этот размер.

**Примечание 3**. Если вы попытаетесь записать больше, чем размер, установленный в записи, ваши записи будут усечены; если вы напишете меньше байтов, чем обещали, файл будет расширен нулевыми байтами.

Вышеупомянутый шаблон можно использовать для восстановления каталогов, узлов устройств и FIFO. Та же идея работает и для восстановления символических и жёстких ссылок, но вам нужно инициализировать запись по-другому:

* Символические ссылки имеют тип файла `AE_IFLNK` и требуют, чтобы цель была установлена с помощью `archive_entry_set_symlink()`.
* Жёсткие ссылки требуют, чтобы цель была установлена с помощью `archive_entry_set_hardlink()`; если это установлено, обычный тип файла игнорируется. Если запись, описывающая жёсткую ссылку, имеет размер, вы должны быть готовы записать данные в связанные файлы. Если вы не хотите перезаписывать файл, не устанавливайте размер.

## Готовый экстрактор

Используя описанные выше ср-ва, вы можете извлечь большинство архивов на диск, просто скопировав записи из объекта `archive_read` в объект `archive_write_disk`. Следующий код несколько упрощён по сравнению с файлом `examples/untar.c` из дистрибутива libarchive.

```c
static void
extract(const char *filename)
{
  struct archive *a;
  struct archive *ext;
  struct archive_entry *entry;
  int flags;
  int r;

  /* Select which attributes we want to restore. */
  flags = ARCHIVE_EXTRACT_TIME;
  flags |= ARCHIVE_EXTRACT_PERM;
  flags |= ARCHIVE_EXTRACT_ACL;
  flags |= ARCHIVE_EXTRACT_FFLAGS;

  a = archive_read_new();
  archive_read_support_format_all(a);
  archive_read_support_compression_all(a);
  ext = archive_write_disk_new();
  archive_write_disk_set_options(ext, flags);
  archive_write_disk_set_standard_lookup(ext);
  if ((r = archive_read_open_filename(a, filename, 10240)))
    exit(1);
  for (;;) {
    r = archive_read_next_header(a, &entry);
    if (r == ARCHIVE_EOF)
      break;
    if (r < ARCHIVE_OK)
      fprintf(stderr, "%s\n", archive_error_string(a));
    if (r < ARCHIVE_WARN)
      exit(1);
    r = archive_write_header(ext, entry);
    if (r < ARCHIVE_OK)
      fprintf(stderr, "%s\n", archive_error_string(ext));
    else if (archive_entry_size(entry) > 0) {
      r = copy_data(a, ext);
      if (r < ARCHIVE_OK)
        fprintf(stderr, "%s\n", archive_error_string(ext));
      if (r < ARCHIVE_WARN)
        exit(1);
    }
    r = archive_write_finish_entry(ext);
    if (r < ARCHIVE_OK)
      fprintf(stderr, "%s\n", archive_error_string(ext));
    if (r < ARCHIVE_WARN)
      exit(1);
  }
  archive_read_close(a);
  archive_read_free(a);
  archive_write_close(ext);
  archive_write_free(ext);
  exit(0);
}
```

Вышеупомянутая функция просто считывает заголовки из входного архива и записывает их на диск. Ключевым отсутствующим элементом в приведённом выше примере является функция `copy_data()`, которая фактически извлекает данные из прочитанного архива и записывает их в дескриптор записи:

```c
static int
copy_data(struct archive *ar, struct archive *aw)
{
  int r;
  const void *buff;
  size_t size;
  la_int64_t offset;

  for (;;) {
    r = archive_read_data_block(ar, &buff, &size, &offset);
    if (r == ARCHIVE_EOF)
      return (ARCHIVE_OK);
    if (r < ARCHIVE_OK)
      return (r);
    r = archive_write_data_block(aw, buff, size, offset);
    if (r < ARCHIVE_OK) {
      fprintf(stderr, "%s\n", archive_error_string(aw));
      return (r);
    }
  }
}
```

## Обработка ошибок

Для простоты не все приведённые выше примеры демонстрируют правильную обработку ошибок. Большинство функций libarchive возвращают код состояния, с которым следует действовать.
